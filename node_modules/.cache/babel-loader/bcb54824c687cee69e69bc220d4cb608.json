{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1) arr.push(item);\n}\nfunction removeItem(arr, item) {\n  const index = arr.indexOf(item);\n  if (index > -1) arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n  if (startIndex >= 0 && startIndex < arr.length) {\n    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n    const [item] = arr.splice(fromIndex, 1);\n    arr.splice(endIndex, 0, item);\n  }\n  return arr;\n}\nconst clamp = (min, max, v) => {\n  if (v > max) return max;\n  if (v < min) return min;\n  return v;\n};\nexports.warning = () => {};\nexports.invariant = () => {};\nif (process.env.NODE_ENV !== \"production\") {\n  exports.warning = (check, message) => {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  exports.invariant = (check, message) => {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\nconst MotionGlobalConfig = {};\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = v => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = v => /^0[^.\\s]+$/u.test(v);\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n  let result;\n  return () => {\n    if (result === undefined) result = callback();\n    return result;\n  };\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nconst noop = any => any;\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => v => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\nclass SubscriptionManager {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n  notify(a, b, c) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions) return;\n    if (numSubscriptions === 1) {\n      /**\n       * If there's only a single handler we can just call it without invoking a loop.\n       */\n      this.subscriptions[0](a, b, c);\n    } else {\n      for (let i = 0; i < numSubscriptions; i++) {\n        /**\n         * Check whether the handler exists before firing as it's possible\n         * the subscriptions were modified during this loop running.\n         */\n        const handler = this.subscriptions[i];\n        handler && handler(a, b, c);\n      }\n    }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = seconds => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = milliseconds => milliseconds / 1000;\n\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\nconst warned = new Set();\nfunction hasWarned(message) {\n  return warned.has(message);\n}\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message)) return;\n  console.warn(message);\n  if (element) console.warn(element);\n  warned.add(message);\n}\nconst wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\n/*\n  Bezier function generator\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i = 0;\n  do {\n    currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - x;\n    if (currentX > 0.0) {\n      upperBound = currentT;\n    } else {\n      lowerBound = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n  return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  // If this is a linear gradient, return linear easing\n  if (mX1 === mY1 && mX2 === mY2) return noop;\n  const getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2);\n  // If animation is at start/end, return t without easing\n  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = easing => p => 1 - easing(1 - p);\nconst backOut = /*@__PURE__*/cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/mirrorEasing(backIn);\nconst anticipate = p => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\nconst circIn = p => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\nconst easeIn = /*@__PURE__*/cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/cubicBezier(0.42, 0, 0.58, 1);\nfunction steps(numSteps, direction = \"end\") {\n  return progress => {\n    progress = direction === \"end\" ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n    const expanded = progress * numSteps;\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / numSteps);\n  };\n}\nconst isEasingArray = ease => {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\nfunction getEasingForSegment(easing, i) {\n  return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\nconst isBezierDefinition = easing => Array.isArray(easing) && typeof easing[0] === \"number\";\nconst easingLookup = {\n  linear: noop,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate\n};\nconst isValidEasing = easing => {\n  return typeof easing === \"string\";\n};\nconst easingDefinitionToFunction = definition => {\n  if (isBezierDefinition(definition)) {\n    // If cubic bezier definition, create bezier curve\n    exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (isValidEasing(definition)) {\n    // Else lookup from table\n    exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n  return definition;\n};\nexports.MotionGlobalConfig = MotionGlobalConfig;\nexports.SubscriptionManager = SubscriptionManager;\nexports.addUniqueItem = addUniqueItem;\nexports.anticipate = anticipate;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.cubicBezier = cubicBezier;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.easingDefinitionToFunction = easingDefinitionToFunction;\nexports.getEasingForSegment = getEasingForSegment;\nexports.hasWarned = hasWarned;\nexports.isBezierDefinition = isBezierDefinition;\nexports.isEasingArray = isEasingArray;\nexports.isNumericalString = isNumericalString;\nexports.isObject = isObject;\nexports.isZeroValueString = isZeroValueString;\nexports.memo = memo;\nexports.millisecondsToSeconds = millisecondsToSeconds;\nexports.mirrorEasing = mirrorEasing;\nexports.moveItem = moveItem;\nexports.noop = noop;\nexports.pipe = pipe;\nexports.progress = progress;\nexports.removeItem = removeItem;\nexports.reverseEasing = reverseEasing;\nexports.secondsToMilliseconds = secondsToMilliseconds;\nexports.steps = steps;\nexports.velocityPerSecond = velocityPerSecond;\nexports.warnOnce = warnOnce;\nexports.wrap = wrap;","map":{"version":3,"names":["Object","defineProperty","exports","value","addUniqueItem","arr","item","indexOf","push","removeItem","index","splice","moveItem","fromIndex","toIndex","startIndex","length","endIndex","clamp","min","max","v","warning","invariant","process","env","NODE_ENV","check","message","console","warn","Error","MotionGlobalConfig","isNumericalString","test","isObject","isZeroValueString","memo","callback","result","undefined","noop","any","combineFunctions","a","b","pipe","transformers","reduce","progress","from","to","toFromDifference","SubscriptionManager","constructor","subscriptions","add","handler","notify","c","numSubscriptions","i","getSize","clear","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","velocityPerSecond","velocity","frameDuration","warned","Set","hasWarned","has","warnOnce","condition","element","wrap","rangeSize","calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","x","lowerBound","upperBound","mX1","mX2","currentX","currentT","Math","abs","cubicBezier","mY1","mY2","getTForX","aX","mirrorEasing","easing","p","reverseEasing","backOut","backIn","backInOut","anticipate","pow","circIn","sin","acos","circOut","circInOut","easeIn","easeOut","easeInOut","steps","numSteps","direction","expanded","rounded","floor","ceil","isEasingArray","ease","Array","isArray","getEasingForSegment","isBezierDefinition","easingLookup","linear","isValidEasing","easingDefinitionToFunction","definition","x1","y1","x2","y2"],"sources":["/Users/josephpongonthara/Desktop/palantir_aip/personal_proshop_tennis/node_modules/motion-utils/dist/cjs/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nconst clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nexports.warning = () => { };\nexports.invariant = () => { };\nif (process.env.NODE_ENV !== \"production\") {\n    exports.warning = (check, message) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(message);\n        }\n    };\n    exports.invariant = (check, message) => {\n        if (!check) {\n            throw new Error(message);\n        }\n    };\n}\n\nconst MotionGlobalConfig = {};\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nconst warned = new Set();\nfunction hasWarned(message) {\n    return warned.has(message);\n}\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message))\n        return;\n    console.warn(message);\n    if (element)\n        console.warn(element);\n    warned.add(message);\n}\n\nconst wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\n/*\n  Bezier function generator\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\nfunction steps(numSteps, direction = \"end\") {\n    return (progress) => {\n        progress =\n            direction === \"end\"\n                ? Math.min(progress, 0.999)\n                : Math.max(progress, 0.001);\n        const expanded = progress * numSteps;\n        const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n        return clamp(0, 1, rounded / numSteps);\n    };\n}\n\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst isValidEasing = (easing) => {\n    return typeof easing === \"string\";\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (isValidEasing(definition)) {\n        // Else lookup from table\n        exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\nexports.MotionGlobalConfig = MotionGlobalConfig;\nexports.SubscriptionManager = SubscriptionManager;\nexports.addUniqueItem = addUniqueItem;\nexports.anticipate = anticipate;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.cubicBezier = cubicBezier;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.easingDefinitionToFunction = easingDefinitionToFunction;\nexports.getEasingForSegment = getEasingForSegment;\nexports.hasWarned = hasWarned;\nexports.isBezierDefinition = isBezierDefinition;\nexports.isEasingArray = isEasingArray;\nexports.isNumericalString = isNumericalString;\nexports.isObject = isObject;\nexports.isZeroValueString = isZeroValueString;\nexports.memo = memo;\nexports.millisecondsToSeconds = millisecondsToSeconds;\nexports.mirrorEasing = mirrorEasing;\nexports.moveItem = moveItem;\nexports.noop = noop;\nexports.pipe = pipe;\nexports.progress = progress;\nexports.removeItem = removeItem;\nexports.reverseEasing = reverseEasing;\nexports.secondsToMilliseconds = secondsToMilliseconds;\nexports.steps = steps;\nexports.velocityPerSecond = velocityPerSecond;\nexports.warnOnce = warnOnce;\nexports.wrap = wrap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}